diff -r 8667c26e2bec Include/ceval.h
--- a/Include/ceval.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/ceval.h	Thu Jan 07 11:46:53 2016 -0800
@@ -10,6 +10,11 @@
 PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
     PyObject *, PyObject *, PyObject *);
 
+PyAPI_FUNC(PyObject *) _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,
+PyObject **args, int argcount, PyObject **kws, int kwcount,
+PyObject **defs, int defcount, PyObject *kwdefs, PyObject *closure,
+PyObject *name, PyObject *qualname);
+
 /* Inline this */
 #define PyEval_CallObject(func,arg) \
     PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)
@@ -113,6 +118,7 @@
 PyAPI_FUNC(PyObject *) PyEval_GetCallStats(PyObject *);
 PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
 PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(struct _frame *f, int exc);
+PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx_NoJit(struct _frame *f, int exc);
 
 /* Interface for threads.
 
diff -r 8667c26e2bec Include/code.h
--- a/Include/code.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/code.h	Thu Jan 07 11:46:53 2016 -0800
@@ -7,6 +7,23 @@
 extern "C" {
 #endif
 
+struct _frame;
+
+typedef PyObject* (__stdcall*  Py_EvalFunc)(void*, struct _frame*);
+
+PyAPI_DATA(PyTypeObject) PyJittedCode_Type;
+
+/* Jitted code object.  This object is returned from the JIT implementation.  The JIT can allocate
+   a jitted code object and fill in the state for which is necessary for it to perform an evaluation. */
+typedef struct {
+    PyObject_HEAD
+    Py_EvalFunc j_evalfunc;
+    void* j_evalstate;          /* opaque value, allows the JIT to track any relevant state */
+} PyJittedCode;
+
+/* Creates a new PyJittedCode object which can have the eval function and state populated. */
+PyAPI_FUNC(PyObject*) PyJittedCode_New();
+
 /* Bytecode object */
 typedef struct {
     PyObject_HEAD
@@ -35,8 +52,12 @@
 				   Objects/lnotab_notes.txt for details. */
     void *co_zombieframe;     /* for optimization only (see frameobject.c) */
     PyObject *co_weakreflist;   /* to support weakrefs to code objects */
+    PyJittedCode* co_jitted;    /* Jitted code object */
+    int co_compilefailed;       /* Set to 1 if the compilation has failed and won't be tried again*/
+    int co_runcount;            /* The number of times the code object has been invoked */
 } PyCodeObject;
 
+
 /* Masks for co_flags above */
 #define CO_OPTIMIZED	0x0001
 #define CO_NEWLOCALS	0x0002
diff -r 8667c26e2bec Include/dictobject.h
--- a/Include/dictobject.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/dictobject.h	Thu Jan 07 11:46:53 2016 -0800
@@ -138,7 +138,7 @@
 PyAPI_FUNC(void) _PyDict_DebugMallocStats(FILE *out);
 
 int _PyObjectDict_SetItem(PyTypeObject *tp, PyObject **dictptr, PyObject *name, PyObject *value);
-PyObject *_PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);
 #endif
 
 #ifdef __cplusplus
diff -r 8667c26e2bec Include/pystate.h
--- a/Include/pystate.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/pystate.h	Thu Jan 07 11:46:53 2016 -0800
@@ -12,6 +12,9 @@
 
 struct _ts; /* Forward */
 struct _is; /* Forward */
+typedef void*(__stdcall *CompileFunction)(PyObject*);
+typedef void*(__stdcall *JitFreeFunction)(PyObject*);
+typedef void(__stdcall *JitInitFunction)();
 
 #ifdef Py_LIMITED_API
 typedef struct _is PyInterpreterState;
@@ -41,6 +44,8 @@
 #endif
 
     PyObject *builtins_copy;
+    CompileFunction jitcompile;
+    JitFreeFunction jitfree;
 } PyInterpreterState;
 #endif
 
diff -r 8667c26e2bec Lib/test/test_list.py
--- a/Lib/test/test_list.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_list.py	Thu Jan 07 11:46:53 2016 -0800
@@ -1,6 +1,7 @@
 import sys
 from test import support, list_tests
 import pickle
+import unittest
 
 class ListTest(list_tests.CommonTest):
     type2test = list
diff -r 8667c26e2bec Objects/codeobject.c
--- a/Objects/codeobject.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Objects/codeobject.c	Thu Jan 07 11:46:53 2016 -0800
@@ -7,6 +7,7 @@
 
 /* all_name_chars(s): true iff all chars in s are valid NAME_CHARS */
 
+
 static int
 all_name_chars(PyObject *o)
 {
@@ -152,6 +153,9 @@
     co->co_lnotab = lnotab;
     co->co_zombieframe = NULL;
     co->co_weakreflist = NULL;
+    co->co_jitted = NULL;
+    co->co_compilefailed = 0;
+    co->co_runcount = 0;
     return co;
 }
 
@@ -370,6 +374,7 @@
     Py_XDECREF(co->co_filename);
     Py_XDECREF(co->co_name);
     Py_XDECREF(co->co_lnotab);
+    Py_XDECREF(co->co_jitted);
     if (co->co_cell2arg != NULL)
         PyMem_FREE(co->co_cell2arg);
     if (co->co_zombieframe != NULL)
@@ -542,6 +547,69 @@
     code_new,                           /* tp_new */
 };
 
+static PyObject *
+jittedcode_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    if (PyTuple_GET_SIZE(args) || (kwargs && PyDict_Size(kwargs))) {
+        PyErr_SetString(PyExc_TypeError, "JittedCode takes no arguments");
+        return NULL;
+    }
+    return PyJittedCode_New(0);
+}
+
+PyObject* PyJittedCode_New() {
+    return PyObject_New(PyJittedCode, &PyJittedCode_Type);
+}
+
+static void
+jittedcode_dealloc(PyJittedCode *co) {
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate->interp->jitfree != NULL) {
+        tstate->interp->jitfree(co);
+    }
+}
+
+PyTypeObject PyJittedCode_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "jittedcode",                       /* tp_name */
+    sizeof(PyJittedCode),               /* tp_basicsize */
+    0,                                  /* tp_itemsize */
+    jittedcode_dealloc,                 /* tp_dealloc */
+    0,                                  /* tp_print */
+    0,                                  /* tp_getattr */
+    0,                                  /* tp_setattr */
+    0,                                  /* tp_reserved */
+    0,                                  /* tp_repr */
+    0,                                  /* tp_as_number */
+    0,                                  /* tp_as_sequence */
+    0,                                  /* tp_as_mapping */
+    0,                                  /* tp_hash */
+    0,                                  /* tp_call */
+    0,                                  /* tp_str */
+    0,                                  /* tp_getattro */
+    0,                                  /* tp_setattro */
+    0,                                  /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT,                 /* tp_flags */
+    0,                                  /* tp_doc */
+    0,                                  /* tp_traverse */
+    0,                                  /* tp_clear */
+    0,                                  /* tp_richcompare */
+    0,                                  /* tp_weaklistoffset */
+    0,                                  /* tp_iter */
+    0,                                  /* tp_iternext */
+    0,                                  /* tp_methods */
+    0,                                  /* tp_members */
+    0,                                  /* tp_getset */
+    0,                                  /* tp_base */
+    0,                                  /* tp_dict */
+    0,                                  /* tp_descr_get */
+    0,                                  /* tp_descr_set */
+    0,                                  /* tp_dictoffset */
+    0,                                  /* tp_init */
+    0,                                  /* tp_alloc */
+    jittedcode_new,                     /* tp_new */
+};
+
 /* Use co_lnotab to compute the line number from a bytecode index, addrq.  See
    lnotab_notes.txt for the details of the lnotab representation.
 */
diff -r 8667c26e2bec Python/ceval.c
--- a/Python/ceval.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/ceval.c	Thu Jan 07 11:46:53 2016 -0800
@@ -796,6 +796,31 @@
 PyObject *
 PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)
 {
+    if (f->f_code->co_jitted != NULL) {
+        return f->f_code->co_jitted->j_evalfunc(f->f_code->co_jitted->j_evalstate, f);
+    }
+
+    if (!f->f_code->co_compilefailed /*&& f->f_code->co_runcount++ >20 */) {
+        PyThreadState *tstate = PyThreadState_GET();
+        if (tstate->interp->jitcompile != NULL) {
+            f->f_code->co_jitted = tstate->interp->jitcompile((PyObject*)f->f_code);
+            if (f->f_code->co_jitted != NULL) {
+                // execute the jitted code...
+                return f->f_code->co_jitted->j_evalfunc(f->f_code->co_jitted->j_evalstate, f);
+            }
+
+            // no longer try and compile this method...
+            f->f_code->co_compilefailed = 1;
+        }
+    }
+
+    return PyEval_EvalFrameEx_NoJit(f, throwflag);
+}
+
+
+PyObject *
+PyEval_EvalFrameEx_NoJit(PyFrameObject *f, int throwflag)
+{
 #ifdef DXPAIRS
     int lastopcode = 0;
 #endif
diff -r 8667c26e2bec Python/pylifecycle.c
--- a/Python/pylifecycle.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/pylifecycle.c	Thu Jan 07 11:46:53 2016 -0800
@@ -321,6 +321,20 @@
     if (interp == NULL)
         Py_FatalError("Py_Initialize: can't make first interpreter");
 
+    HMODULE pyjit = LoadLibrary("pyjit.dll");
+    if (pyjit != NULL) {
+        interp->jitcompile = (CompileFunction)GetProcAddress(pyjit, "JitCompile");
+        if (interp->jitcompile != NULL) {
+            JitInitFunction jitinit = (JitInitFunction)GetProcAddress(pyjit, "JitInit");
+            jitinit();
+
+            interp->jitfree = (JitFreeFunction)GetProcAddress(pyjit, "JitFree");
+        }
+    }
+    else {
+        interp->jitcompile = NULL;
+    }
+
     tstate = PyThreadState_New(interp);
     if (tstate == NULL)
         Py_FatalError("Py_Initialize: can't make first thread");
diff -r 8667c26e2bec Python/pystate.c
--- a/Python/pystate.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/pystate.c	Thu Jan 07 11:46:53 2016 -0800
@@ -80,6 +80,8 @@
         interp->codecs_initialized = 0;
         interp->fscodec_initialized = 0;
         interp->importlib = NULL;
+        interp->jitcompile = NULL;
+        interp->jitfree = NULL;
 #ifdef HAVE_DLOPEN
 #ifdef RTLD_NOW
         interp->dlopenflags = RTLD_NOW;
