diff -r 8667c26e2bec Include/ceval.h
--- a/Include/ceval.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/ceval.h	Tue Feb 02 12:06:26 2016 -0800
@@ -10,6 +10,11 @@
 PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
     PyObject *, PyObject *, PyObject *);
 
+PyAPI_FUNC(PyObject *) _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,
+PyObject **args, int argcount, PyObject **kws, int kwcount,
+PyObject **defs, int defcount, PyObject *kwdefs, PyObject *closure,
+PyObject *name, PyObject *qualname);
+
 /* Inline this */
 #define PyEval_CallObject(func,arg) \
     PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)
@@ -82,6 +87,11 @@
 PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
 PyAPI_DATA(int) _Py_CheckRecursionLimit;
 
+/* Checks to see if periodic work needs to be done, such as releasing the GIL,
+   make any pending calls, or raising an asychronous exception.  Returns true
+   if an error occurred or false on success. */
+PyAPI_FUNC(int) _PyEval_PeriodicWork(void);
+
 #ifdef USE_STACKCHECK
 /* With USE_STACKCHECK, we artificially decrement the recursion limit in order
    to trigger regular stack checks in _Py_CheckRecursiveCall(), except if
@@ -113,6 +123,7 @@
 PyAPI_FUNC(PyObject *) PyEval_GetCallStats(PyObject *);
 PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
 PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(struct _frame *f, int exc);
+PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx_NoJit(struct _frame *f, int exc);
 
 /* Interface for threads.
 
diff -r 8667c26e2bec Include/code.h
--- a/Include/code.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/code.h	Tue Feb 02 12:06:26 2016 -0800
@@ -7,6 +7,23 @@
 extern "C" {
 #endif
 
+struct _frame;
+
+typedef PyObject* (__stdcall*  Py_EvalFunc)(void*, struct _frame*);
+
+PyAPI_DATA(PyTypeObject) PyJittedCode_Type;
+
+/* Jitted code object.  This object is returned from the JIT implementation.  The JIT can allocate
+   a jitted code object and fill in the state for which is necessary for it to perform an evaluation. */
+typedef struct {
+    PyObject_HEAD
+    Py_EvalFunc j_evalfunc;
+    void* j_evalstate;          /* opaque value, allows the JIT to track any relevant state */
+} PyJittedCode;
+
+/* Creates a new PyJittedCode object which can have the eval function and state populated. */
+PyAPI_FUNC(PyObject*) PyJittedCode_New();
+
 /* Bytecode object */
 typedef struct {
     PyObject_HEAD
@@ -35,8 +52,12 @@
 				   Objects/lnotab_notes.txt for details. */
     void *co_zombieframe;     /* for optimization only (see frameobject.c) */
     PyObject *co_weakreflist;   /* to support weakrefs to code objects */
+    PyJittedCode* co_jitted;    /* Jitted code object */
+    int co_compilefailed;       /* Set to 1 if the compilation has failed and won't be tried again*/
+    int co_runcount;            /* The number of times the code object has been invoked */
 } PyCodeObject;
 
+
 /* Masks for co_flags above */
 #define CO_OPTIMIZED	0x0001
 #define CO_NEWLOCALS	0x0002
diff -r 8667c26e2bec Include/dictobject.h
--- a/Include/dictobject.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/dictobject.h	Tue Feb 02 12:06:26 2016 -0800
@@ -138,7 +138,7 @@
 PyAPI_FUNC(void) _PyDict_DebugMallocStats(FILE *out);
 
 int _PyObjectDict_SetItem(PyTypeObject *tp, PyObject **dictptr, PyObject *name, PyObject *value);
-PyObject *_PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);
 #endif
 
 #ifdef __cplusplus
diff -r 8667c26e2bec Include/pystate.h
--- a/Include/pystate.h	Mon Jun 15 09:11:37 2015 -0700
+++ b/Include/pystate.h	Tue Feb 02 12:06:26 2016 -0800
@@ -12,6 +12,9 @@
 
 struct _ts; /* Forward */
 struct _is; /* Forward */
+typedef void*(__stdcall *CompileFunction)(PyObject*);
+typedef void*(__stdcall *JitFreeFunction)(PyObject*);
+typedef void(__stdcall *JitInitFunction)();
 
 #ifdef Py_LIMITED_API
 typedef struct _is PyInterpreterState;
@@ -41,6 +44,8 @@
 #endif
 
     PyObject *builtins_copy;
+    CompileFunction jitcompile;
+    JitFreeFunction jitfree;
 } PyInterpreterState;
 #endif
 
diff -r 8667c26e2bec Lib/test/test_list.py
--- a/Lib/test/test_list.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_list.py	Tue Feb 02 12:06:26 2016 -0800
@@ -1,6 +1,7 @@
 import sys
 from test import support, list_tests
 import pickle
+import unittest
 
 class ListTest(list_tests.CommonTest):
     type2test = list
diff -r 8667c26e2bec Lib/test/test_sys.py
--- a/Lib/test/test_sys.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_sys.py	Tue Feb 02 12:06:26 2016 -0800
@@ -857,13 +857,13 @@
             return inner
         check(get_cell().__closure__[0], size('P'))
         # code
-        check(get_cell().__code__, size('5i9Pi3P'))
-        check(get_cell.__code__, size('5i9Pi3P'))
+        check(get_cell().__code__, size('5i9Pi4P2i'))
+        check(get_cell.__code__, size('5i9Pi4P2i'))
         def get_cell2(x):
             def inner():
                 return x
             return inner
-        check(get_cell2.__code__, size('5i9Pi3P') + 1)
+        check(get_cell2.__code__, size('5i9Pi4P2i') + 1)
         # complex
         check(complex(0,1), size('2d'))
         # method_descriptor (descriptor object)
diff -r 8667c26e2bec Lib/test/test_telnetlib.py
--- a/Lib/test/test_telnetlib.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_telnetlib.py	Tue Feb 02 12:06:26 2016 -0800
@@ -3,6 +3,7 @@
 import telnetlib
 import time
 import contextlib
+import unittest
 
 from unittest import TestCase
 from test import support
diff -r 8667c26e2bec Lib/test/test_tuple.py
--- a/Lib/test/test_tuple.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_tuple.py	Tue Feb 02 12:06:26 2016 -0800
@@ -2,6 +2,7 @@
 
 import gc
 import pickle
+import unittest
 
 class TupleTest(seq_tests.CommonTest):
     type2test = tuple
diff -r 8667c26e2bec Lib/test/test_userdict.py
--- a/Lib/test/test_userdict.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_userdict.py	Tue Feb 02 12:06:26 2016 -0800
@@ -2,6 +2,7 @@
 
 from test import support, mapping_tests
 import collections
+import unittest
 
 d0 = {}
 d1 = {"one": 1}
diff -r 8667c26e2bec Lib/test/test_userlist.py
--- a/Lib/test/test_userlist.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_userlist.py	Tue Feb 02 12:06:26 2016 -0800
@@ -2,6 +2,7 @@
 
 from collections import UserList
 from test import support, list_tests
+import unittest
 
 class UserListTest(list_tests.CommonTest):
     type2test = UserList
diff -r 8667c26e2bec Lib/test/test_wsgiref.py
--- a/Lib/test/test_wsgiref.py	Mon Jun 15 09:11:37 2015 -0700
+++ b/Lib/test/test_wsgiref.py	Tue Feb 02 12:06:26 2016 -0800
@@ -14,6 +14,7 @@
 import os
 import re
 import sys
+import unittest
 
 from test import support
 
diff -r 8667c26e2bec Objects/codeobject.c
--- a/Objects/codeobject.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Objects/codeobject.c	Tue Feb 02 12:06:26 2016 -0800
@@ -7,6 +7,7 @@
 
 /* all_name_chars(s): true iff all chars in s are valid NAME_CHARS */
 
+
 static int
 all_name_chars(PyObject *o)
 {
@@ -152,6 +153,9 @@
     co->co_lnotab = lnotab;
     co->co_zombieframe = NULL;
     co->co_weakreflist = NULL;
+    co->co_jitted = NULL;
+    co->co_compilefailed = 0;
+    co->co_runcount = 0;
     return co;
 }
 
@@ -370,6 +374,7 @@
     Py_XDECREF(co->co_filename);
     Py_XDECREF(co->co_name);
     Py_XDECREF(co->co_lnotab);
+    Py_XDECREF(co->co_jitted);
     if (co->co_cell2arg != NULL)
         PyMem_FREE(co->co_cell2arg);
     if (co->co_zombieframe != NULL)
@@ -542,6 +547,69 @@
     code_new,                           /* tp_new */
 };
 
+static PyObject *
+jittedcode_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    if (PyTuple_GET_SIZE(args) || (kwargs && PyDict_Size(kwargs))) {
+        PyErr_SetString(PyExc_TypeError, "JittedCode takes no arguments");
+        return NULL;
+    }
+    return PyJittedCode_New(0);
+}
+
+PyObject* PyJittedCode_New() {
+    return PyObject_New(PyJittedCode, &PyJittedCode_Type);
+}
+
+static void
+jittedcode_dealloc(PyJittedCode *co) {
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate->interp->jitfree != NULL) {
+        tstate->interp->jitfree(co);
+    }
+}
+
+PyTypeObject PyJittedCode_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "jittedcode",                       /* tp_name */
+    sizeof(PyJittedCode),               /* tp_basicsize */
+    0,                                  /* tp_itemsize */
+    jittedcode_dealloc,                 /* tp_dealloc */
+    0,                                  /* tp_print */
+    0,                                  /* tp_getattr */
+    0,                                  /* tp_setattr */
+    0,                                  /* tp_reserved */
+    0,                                  /* tp_repr */
+    0,                                  /* tp_as_number */
+    0,                                  /* tp_as_sequence */
+    0,                                  /* tp_as_mapping */
+    0,                                  /* tp_hash */
+    0,                                  /* tp_call */
+    0,                                  /* tp_str */
+    0,                                  /* tp_getattro */
+    0,                                  /* tp_setattro */
+    0,                                  /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT,                 /* tp_flags */
+    0,                                  /* tp_doc */
+    0,                                  /* tp_traverse */
+    0,                                  /* tp_clear */
+    0,                                  /* tp_richcompare */
+    0,                                  /* tp_weaklistoffset */
+    0,                                  /* tp_iter */
+    0,                                  /* tp_iternext */
+    0,                                  /* tp_methods */
+    0,                                  /* tp_members */
+    0,                                  /* tp_getset */
+    0,                                  /* tp_base */
+    0,                                  /* tp_dict */
+    0,                                  /* tp_descr_get */
+    0,                                  /* tp_descr_set */
+    0,                                  /* tp_dictoffset */
+    0,                                  /* tp_init */
+    0,                                  /* tp_alloc */
+    jittedcode_new,                     /* tp_new */
+};
+
 /* Use co_lnotab to compute the line number from a bytecode index, addrq.  See
    lnotab_notes.txt for the details of the lnotab representation.
 */
diff -r 8667c26e2bec Python/ceval.c
--- a/Python/ceval.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/ceval.c	Tue Feb 02 12:06:26 2016 -0800
@@ -769,6 +769,54 @@
    fast_next_opcode*/
 static int _Py_TracingPossible = 0;
 
+#ifdef WITH_THREAD
+#define PULSE_GIL(tstate)                                       \
+    if (_Py_atomic_load_relaxed(&gil_drop_request)) {           \
+        /* Give another thread a chance */                      \
+        if (PyThreadState_Swap(NULL) != tstate)                 \
+            Py_FatalError("ceval: tstate mix-up");              \
+        drop_gil(tstate);                                       \
+                                                                \
+        /* Other threads may run now */                         \
+                                                                \
+        take_gil(tstate);                                       \
+                                                                \
+        /* Check if we should make a quick exit. */             \
+        if (_Py_Finalizing && _Py_Finalizing != tstate) {       \
+            drop_gil(tstate);                                   \
+            PyThread_exit_thread();                             \
+        }                                                       \
+                                                                \
+        if (PyThreadState_Swap(tstate) != NULL)                 \
+            Py_FatalError("ceval: orphan tstate");              \
+    }
+
+#endif
+
+int _PyEval_PeriodicWork(void) {
+    if (_Py_atomic_load_relaxed(&eval_breaker)) {
+        if (_Py_atomic_load_relaxed(&pendingcalls_to_do)) {
+            if (Py_MakePendingCalls() < 0) {
+                return 1;
+            }
+        }
+
+        PyThreadState* tstate = PyThreadState_GET();
+#ifdef WITH_THREAD
+        PULSE_GIL(tstate);
+#endif
+
+        if (tstate->async_exc != NULL) {
+            PyObject *exc = tstate->async_exc;
+            tstate->async_exc = NULL;
+            UNSIGNAL_ASYNC_EXC();
+            PyErr_SetNone(exc);
+            Py_DECREF(exc);
+            return 1;
+        }
+    }
+    return 0;
+}
 
 
 PyObject *
@@ -796,6 +844,31 @@
 PyObject *
 PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)
 {
+    if (f->f_code->co_jitted != NULL) {
+        return f->f_code->co_jitted->j_evalfunc(f->f_code->co_jitted->j_evalstate, f);
+    }
+
+    if (!f->f_code->co_compilefailed /*&& f->f_code->co_runcount++ >20 */) {
+        PyThreadState *tstate = PyThreadState_GET();
+        if (tstate->interp->jitcompile != NULL) {
+            f->f_code->co_jitted = tstate->interp->jitcompile((PyObject*)f->f_code);
+            if (f->f_code->co_jitted != NULL) {
+                // execute the jitted code...
+                return f->f_code->co_jitted->j_evalfunc(f->f_code->co_jitted->j_evalstate, f);
+            }
+
+            // no longer try and compile this method...
+            f->f_code->co_compilefailed = 1;
+        }
+    }
+
+    return PyEval_EvalFrameEx_NoJit(f, throwflag);
+}
+
+
+PyObject *
+PyEval_EvalFrameEx_NoJit(PyFrameObject *f, int throwflag)
+{
 #ifdef DXPAIRS
     int lastopcode = 0;
 #endif
@@ -1262,25 +1335,7 @@
                     goto error;
             }
 #ifdef WITH_THREAD
-            if (_Py_atomic_load_relaxed(&gil_drop_request)) {
-                /* Give another thread a chance */
-                if (PyThreadState_Swap(NULL) != tstate)
-                    Py_FatalError("ceval: tstate mix-up");
-                drop_gil(tstate);
-
-                /* Other threads may run now */
-
-                take_gil(tstate);
-
-                /* Check if we should make a quick exit. */
-                if (_Py_Finalizing && _Py_Finalizing != tstate) {
-                    drop_gil(tstate);
-                    PyThread_exit_thread();
-                }
-
-                if (PyThreadState_Swap(tstate) != NULL)
-                    Py_FatalError("ceval: orphan tstate");
-            }
+            PULSE_GIL(tstate);
 #endif
             /* Check for asynchronous exceptions. */
             if (tstate->async_exc != NULL) {
diff -r 8667c26e2bec Python/pylifecycle.c
--- a/Python/pylifecycle.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/pylifecycle.c	Tue Feb 02 12:06:26 2016 -0800
@@ -321,6 +321,20 @@
     if (interp == NULL)
         Py_FatalError("Py_Initialize: can't make first interpreter");
 
+    HMODULE pyjit = LoadLibrary("pyjit.dll");
+    if (pyjit != NULL) {
+        interp->jitcompile = (CompileFunction)GetProcAddress(pyjit, "JitCompile");
+        if (interp->jitcompile != NULL) {
+            JitInitFunction jitinit = (JitInitFunction)GetProcAddress(pyjit, "JitInit");
+            jitinit();
+
+            interp->jitfree = (JitFreeFunction)GetProcAddress(pyjit, "JitFree");
+        }
+    }
+    else {
+        interp->jitcompile = NULL;
+    }
+
     tstate = PyThreadState_New(interp);
     if (tstate == NULL)
         Py_FatalError("Py_Initialize: can't make first thread");
diff -r 8667c26e2bec Python/pystate.c
--- a/Python/pystate.c	Mon Jun 15 09:11:37 2015 -0700
+++ b/Python/pystate.c	Tue Feb 02 12:06:26 2016 -0800
@@ -80,6 +80,8 @@
         interp->codecs_initialized = 0;
         interp->fscodec_initialized = 0;
         interp->importlib = NULL;
+        interp->jitcompile = NULL;
+        interp->jitfree = NULL;
 #ifdef HAVE_DLOPEN
 #ifdef RTLD_NOW
         interp->dlopenflags = RTLD_NOW;
